; ==============================================================================
; Mesh asset

MESH_ASSET_ID = ASSET_ID

MESH_ASSET = {
    ; Optional name for asset
    ? 0: text,

    ; Uncompressed representation
    1: UNCOMPRESSED_MESH,
}

; ==============================================================================
; Uncompressed content

; In this design we force all attributes to be sourced from a single buffer_source
; In a previous approach, these could be different, possibly sourcing disjoint buffers,
; from each. This was so that maximum compression could be acheived, and if the mesh
; needed to be updated, only fractions of the mesh needed to be so.
; This was a huge pain. Few, if any, implementations took advantage of it.
; Since buffers can be fetched async, there was a lot of code needed to deal with
; Delayed loading for some platforms.
; If we need a split again, we can add another mesh type.
UNCOMPRESSED_MESH = {
    ; Bytes to source mesh content
    0: BUFFER_VIEW,

    ; 'Patch' or submesh that may use different materials...
    1: [+ UNCOMPRESSED_PATCH]  
}

UNCOMPRESSED_PATCH = {
    ; Vertex count
    1: uint

    ; Type
    2: PRIMITIVE_TYPE

    ; Optional index information
    ? 3: UNCOMPRESSED_INDEX,

    5: POSITION_ATTRIB,
    ? 6: NORMAL_ATTRIB,
    ? 7: TANGENT_ATTRIB,
    ; No color attribute at this time. Not a lot of support
    ; without custom shaders on a lot of platforms.

    ; UV_0 slot
    ? 9: TEXTURE_ATTRIB,
    ; UV_1 slot
    ? 10: TEXTURE_ATTRIB, 
}

PRIMITIVE_TYPE = 
    0 ; Triangle geometry

UNCOMPRESSED_ATTRIB_COMMON = (
    ; Byte offset into the view that the attribute starts
    ? 1: uint ; Default 0

    ; Byte offset between attribute instances
    ? 2: uint ; Default 0

    ; Per-channel minimum and maximum values of the attribute.
    ; Can be used for optimization, and, for position, culling.
    ; Thus, strongly recommended for position semantics, but optional for others.
    ? 3: minimum_value : [* float],
    ? 4: maximum_value : [* float],
)


ATTR_VEC2 = 0 ; a pair of IEEE float32
ATTR_U16VEC2_N = 1 ; a pair of two unsigned shorts, normalized interpretation
ATTR_VEC3 = 2 ; a tuple of 3 IEEE float32
ATTR_VEC4 = 3 ; a tuple of 4 IEEE float32.  W is handedness for tangents


POSITION_ATTRIB = {
    UNCOMPRESSED_ATTRIB_COMMON,
    ; Format
    5: ATTR_VEC3 ; Must be this for now
}

NORMAL_ATTRIB = {
    UNCOMPRESSED_ATTRIB_COMMON,
    ; Format
    5: ATTR_VEC3 ; Must be this for now
}

TANGENT_ATTRIB = {
    UNCOMPRESSED_ATTRIB_COMMON,
    ; Format
    5: ATTR_VEC3 / ATTR_VEC4
}

TEXTURE_ATTRIB = {
    UNCOMPRESSED_ATTRIB_COMMON,
    ; Format
    5: ATTR_VEC2 / ATTR_U16VEC2_N
}

INDEX_FORMAT = 
    0 / ; U8. This format may not be supported on all targets, and may require conversion
    1 / ; U16.
    2  ; U32. This format is the most compatible.

UNCOMPRESSED_INDEX = {
    ; Byte offset into the view of where to begin reading elements
    0: uint,

    ; Count of index elements
    1: uint,

    ; Format of index list.
    ; If missing, assume u32
    ? 2: INDEX_FORMAT,
}