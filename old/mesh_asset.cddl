; ==============================================================================
; Mesh asset

MESH_ASSET_ID = ASSET_ID

MESH_ASSET = {
    ; Uncompressed representation
    UNCOMPRESSED_MESH,
}

; ==============================================================================
; Uncompressed content

; In this design we force all attributes to be sourced from a single buffer_source
; In a previous approach, these could be different, possibly sourcing disjoint buffers,
; from each. This was so that maximum compression could be acheived, and if the mesh
; needed to be updated, only fractions of the mesh needed to be so.
; This was a huge pain. Few, if any, implementations took advantage of it.
; Since buffers can be fetched async, there was a lot of code needed to deal with
; Delayed loading for some platforms.
; If we need a split again, we can add another mesh type.
UNCOMPRESSED_MESH = (
    ; Bytes to source mesh content
    BUFFER_VIEW,

    ; 'Patch' or submesh that may use different materials. A mesh with no patches is an error.
    ARRAY<u8, UNCOMPRESSED_PATCH>
)

UNCOMPRESSED_PATCH = (
    ; Vertex count
    vertex_count: u32,
    flags: UNCOMPRESSED_FLAGS,

    POSITION_ATTRIB,

    ; Optional index information
    index: EXTERNAL_OPTION< UNCOMPRESSED_INDEX >,
    normal: EXTERNAL_OPTION< NORMAL_ATTRIB >,
    tangent: EXTERNAL_OPTION< TANGENT_ATTRIB >,
    ; No color attribute at this time. Not a lot of support
    ; without custom shaders on a lot of platforms.

    ; UV_0 slot
    texture_0: EXTERNAL_OPTION< TEXTURE_ATTRIB >,
    ; UV_1 slot
    texture_1: EXTERNAL_OPTION< TEXTURE_ATTRIB >, 

    EXTENSION_POINT,
)

;Bit 0: Index?
;Bit 1: Normal?
;Bit 2: Tangent?
;Bit 3: Texture 0?
;Bit 4: Texture 1?
;Bit 5-7: PRIMITIVE_TYPE
UNCOMPRESSED_FLAGS = u32

PRIMITIVE_TYPE = 
    0 ; Triangles geometry

UNCOMPRESSED_ATTRIB_COMMON = (
    ; Byte offset into the view that the attribute starts
    u64,

    ; Byte offset between attribute instances
    u16,

    ; Per-channel minimum and then maximum values of the attribute, stored in a single array.
    ; Can be used for optimization, and, for position, culling.
    ; Thus, strongly recommended for position semantics, but optional (empty) for others.
    VEC3,
)

; These are all u8
ATTR_VEC2 = 0 ; a pair of IEEE float32
ATTR_U16VEC2_N = 1 ; a pair of two unsigned shorts, normalized interpretation
ATTR_VEC3 = 2 ; a tuple of 3 IEEE float32
ATTR_VEC4 = 3 ; a tuple of 4 IEEE float32.  W is handedness for tangents


POSITION_ATTRIB = (
    UNCOMPRESSED_ATTRIB_COMMON,
    ; Format
    ATTR_VEC3 ; Must be this for now
)

NORMAL_ATTRIB = (
    UNCOMPRESSED_ATTRIB_COMMON,
    ; Format
    ATTR_VEC3 ; Must be this for now
)

TANGENT_ATTRIB = (
    UNCOMPRESSED_ATTRIB_COMMON,
    ; Format
    ATTR_VEC4
)

TEXTURE_ATTRIB = (
    UNCOMPRESSED_ATTRIB_COMMON,
    ; Format
    (ATTR_VEC2 / ATTR_U16VEC2_N)
)

; must be a u8 integer
INDEX_FORMAT = 
    1 / ; U8. This format may not be supported on all targets, and may require conversion
    2 / ; U16.
    4  ; U32. This format is the most compatible.

UNCOMPRESSED_INDEX = (
    ; Byte offset into the view of where to begin reading elements
    u64,

    ; Count of index elements
    u32,

    ; Format of index list.
    ; If missing, assume u32
    INDEX_FORMAT,
)