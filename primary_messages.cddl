UNCLASSIFIED_MESSAGES = 
    MESSAGE_INTRO /
    MESSAGE_PROBE

UPSTREAM_TO_DOWNSTREAM_MESSAGES =
    MESSAGE_TRANSACTION /
    MESSAGE_TRANSACTION_REPLY /
    MESSAGE_RPC_INVOKE_REPLY /
    MESSAGE_RPC_INVOKE_BATCH_REPLY /
    MESSAGE_RPC_INFORMATION

DOWNSTREAM_TO_UPSTREAM_MESSAGES = 
    MESSAGE_TRANSACTION /
    MESSAGE_RPC_INVOKE /
    MESSAGE_RPC_INVOKE_BATCH

; ==============================================================================
; Introduction messages

; NODE: Upstream or Downstream
; Introduction sent on first connection
MESSAGE_INTRO = (
    MESSAGE_INTRO_ID,
    ; IDENTITY
    UUID, ; _must_ be UUID

    ; The compatibility version of the protocol this node is operating with
    ; Similar
    PROTOCOL_VERSION,

    ; NAME, a human friendly name
    SMALL_STRING, 
    ; Request Authority, ask to reverse the client-server order
    bool,
)

; All NODES with the same compat version are expected to be interoperable. 
; Those with different versions may require compatability 'thunks' that allow them to speak
; at the other's protocol level.
PROTOCOL_VERSION = (u16)

; Intro reply sent on successful introduction
MESSAGE_INTRO_REPLY = (
    MESSAGE_INTRO_REPLY_ID,

    ; NAME, the human friendly name of the server/session
    SMALL_STRING, 

    ; ASSET STREAM, optional asset stream context 
    OPTION< LARGE_ASSET_STREAM_INFO >
)

LARGE_ASSET_STREAM_INFO = (
    ; ASSET_PORT, the ports that you can connect to. 
    ; The host is the same as the initial connection
    ARRAY<u16, u16>, 
    ; ASSET_PROTO, the protocol to use to obtain content
    ; for now, MUST BE "ws" or "wss" for websocket
    SMALL_STRING, 
)

; NODE: Upstream or Downstream
; Inquiry message to obtain server info. This message is intended to be used
; in exclusion to all others. If sent, the server will send a query reply
; and then MUST close the connection.
MESSAGE_PROBE = (
    MESSAGE_PROBE_ID,
)

MESSAGE_PROBE_REPLY = (
    MESSAGE_PROBE_REPLY_ID,
    ; NAME a human-friendly name for this server/session
    SMALL_STRING, 
    ; ICON a SMALL PNG, JPEG or SVG, image, that describes the session
    ; Note that while the technical limitation is large, it is an error to
    ; send an icon larger than 1 MB. 
    ICON_BYTE_STRING
)

ICON_BYTE_STRING = ARRAY<u32, u8>

; ==============================================================================
; Transaction message

; NODE: Upstream or Downstream
; Transactions have an identifier, to be used with replies.
; If the message is Upstream to Downstream, no ID is required
; - It is expected that the client will do as requested, and the server would not care if a transaction 
;   was rejected.
; If the message is Downstream to Upstream, an ID _should_ be provided
; - The client will need an indication of a transaction accept or reject
; - The client may elect to omit the ID and thus signal it is not interested in a response
MESSAGE_TRANSACTION = (
    MESSAGE_TRANSACTION_ID,
    NON_NEGATIVE_OPTION<TRANSACTION_IDENTIFIER>,
    ; An array of content messages
    ARRAY<u32, CONTENT_MESSAGE>
)

; NODE: U -> D
; Indication if the transaction was accepted or rejected.
MESSAGE_TRANSACTION_REPLY = (
    MESSAGE_TRANSACTION_REPLY_ID,
    TRANSACTION_IDENTIFIER,
    bool,
)

TRANSACTION_IDENTIFIER = i32

; ==============================================================================
; RPC

; NODE: U -> D
; Tells you that an RPC endpoint exists
MESSAGE_RPC_INFORMATION = (
    MESSAGE_RPC_ID,
    
    ARRAY<u32, RPC_ENDPOINT_MAPPING>
)

RPC_ENDPOINT_ID = u32
RPC_ENDPOINT_MAPPING = (RPC_ENDPOINT_ID, RPC_ENDPOINT)

RPC_ENDPOINT = (
    ; NAME. Human friendly name/label. This may be any string, but should be a 
    ; short active sentence that indicates what this call does.
    ; A good example is "Create marker" or "Run simulation"
    SMALL_STRING,

    ; ICON. This is a PNG of an icon image to use. The image _should_ be 
    ; transparent, with content in black to indicate the function.
    ; This is to support recoloring for client UIs
    BYTE_STRING,

    ; Arguments. If exists, this is the list of expected arguments to this 
    ; function
    ARRAY<u8, ArgumentHint>,

    ; Return value. If exists, this is the expected return value.
    OPTION<ArgumentHint>
)

ArgumentHint = (
    ; Variable text, human friendly, should be short
    SHORT_STRING,

    ; The definition of the variable
    ARRAY<u8, VariableDef>
)

VariableDef = (
    ; The type of the variable
    ANY_ID,
    ; Bounds
    BOUNDS
)

BOUNDS = (
    (0u8) /
    (1u8, RangeBound) /
    (2u8, DiscreteBound) /
    (3u8, StringBound)
)

RangeBound = (
    ANY,
    ANY
)

DiscreteBound = ARRAY<u32, ANY>

StringBound = (
    ; minLength
    u64,
    ; maxLength
    u64
)

; Invoke IDs are reusable; after being used in a request/reply pair, they may be used again
INVOKE_ID = u32

INVOKE_INFO = (
    INVOKE_ID,
    RPC_ENDPOINT_ID, ; the RPC you are invoking
    ARRAY<u8, ANY>,  ; the content of the event
)

; NODE: D -> U
MESSAGE_RPC_INVOKE = (
    MESSAGE_RPC_INVOKE_ID,
    INVOKE_INFO
)


; This is like the JSON RPC batch send. The server may process in serial or parallel and in any order. 
; The batch reply MAY contain all responses; some may be omitted and sent individually.
; Endpoints may be invoked multiple times in the same batch
; NODE: D -> U
MESSAGE_RPC_INVOKE_BATCH = (
    MESSAGE_RPC_INVOKE_BATCH_ID,
    ARRAY<u16, INVOKE_INFO>
)

; NODE: U -> D
; A streaming RPC implies that you can receive more than one reply, at 
; different times.
MESSAGE_RPC_INVOKE_REPLY = (
    MESSAGE_EVENT_INVOKE_REPLY_ID,
    REPLY_PAIR
)

RPC_REPLY = (
    (0u8, ANY) / ; single result, done, or streaming result done.
    (1u8, RPC_ERROR) / ; result was error, done
    (2u8, ANY) / ; streaming result, more results coming!
)

REPLY_PAIR = (
    INVOKE_ID,
    RPC_REPLY
)

; NODE: U -> D
; Batch replies and streaming? How does that work?
; This is like the JSON RPC. The reply here might not contain all from the batch request. They can be in any order
; Other replies might come in after.
MESSAGE_RPC_INVOKE_BATCH_REPLY = (
    MESSAGE_RPC_INVOKE_BATCH_REPLY_ID,
    ARRAY<u16, REPLY_PAIR>
)

RPC_ERROR = (
    CODE: u16,
    ; Message
    LARGE_STRING,
    ; Data
    ANY
)
