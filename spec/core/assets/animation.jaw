# Animation asset: sampler/channel clip layout modeled after glTF.
# Samplers reference key time arrays (f32 seconds) and value arrays whose layout
# depends on the target path. Channels bind a sampler to an entity target.

from "../../common.jaw" use {AnAsset, AssetID, ComponentTypeID, EntityID}
from "buffer.jaw" use {BufferView}

# Sampling / evaluation notes:
# - All times are in seconds. Sampler input times must be finite and non-decreasing.
# - Channels with an unresolved target path MUST be ignored (and SHOULD emit a validation warning).
# - The sampler's output buffer MUST match the expected f32 stride for (value_type, interpolation).

# Rotation requirements:
# - Rotation key values MUST be unit quaternions (implementation SHOULD normalize on load).
# - Hemisphere continuity MUST be enforced for rotation keys (and their tangents if present):
#   For consecutive keys q[i-1], q[i], if dot(q[i-1], q[i]) < 0, negate q[i].
# - Linear rotation interpolation MUST use shortest-path slerp.
# - CubicSpline rotation interpolation:
#   - Treat [in_tangent, value, out_tangent] as 4D quaternion component vectors.
#   - Sample using cubic Hermite per component; then normalize the resulting quaternion.
#   - If the sampled quaternion has near-zero norm, implementations SHOULD fall back to the previous valid rotation.


pack AnimationAssetID
- id : AssetID
pack AnimSamplerAssetID
- id : AssetID

enum AnimInterpolation : u8
> Linear = 0
- Step = 1
- CubicSpline = 2

# Supported animation value types
# For rotations, quaternions must be stored as unit. There must be hemisphere continuity. Linear interpolation is by spherical linear (slerp).
# Colors are provided with alpha, but that channel can be ignored: See coercion in the extension doc.
# No non-alpha color is provided; that breaks the 4-byte size many systems prefer. Color animation is component-wise, as if they were f32.
enum AnimationValueType : u8
> Float = 0         # f32, can be used for scalars and morph weights, etc.
- Float3 = 1        # Vec3 (3 * f32)
- Rotation = 2      # UnitQuaternion (4 * f32, same definition as in common)
- SRGBA8   = 3      # Color, ubyte, with alpha (1 * u32, packed as 1 byte per channel) 

# A path to an a member of a component to animate. The component_id describes the component this path targets.
# The member index identifies the component member to animate. These are documented in the extension.
# The sub-index can be used to address sub-parts of a component member. For example, morph weights.
pack ComponentAnimTarget
- entity : EntityID
- component_id : ComponentTypeID
- member_index : u16
- sub_index : u16 

# A path to an a member of an asset to animate. The component_id describes the component this path targets.
# The member index identifies the asset member to animate. These are documented in the extension.
# The sub-index can be used to address sub-parts of a component member. For example, morph weights.
pack AssetAnimTarget
- asset : AnAsset
- member_index : u16
- sub_index : u16 

# For CubicSpline, output values are laid out as [in_tangent, value, out_tangent]
# per keyframe for the target type.
# - input is a f32 time array, length = keyframe_count. Values must not decrease.
# - output depends on the value type and the interpolation, but must be of size (N * 4 * keyframe_count),
#   Where N is (* 3 if interpolation is cubic spline):
#   - Float => 1
#   - Float3 => 3
#   - Rotation => 4
#   
pack AnimSamplerAsset
- input : BufferView
- output : BufferView  # value array shaped for target path and interpolation
- interpolation : AnimInterpolation
- value_type : AnimationValueType
- keyframe_count : u32

# Sampler indices refer to the AnimationAsset.samplers array.
pack ComponentAnimChannel
- sampler : u16
- target : ComponentAnimTarget

# Sampler indices refer to the AnimationAsset.samplers array.
pack AssetAnimChannel
- sampler : u16
- target : AssetAnimTarget

dyn_array AnimSamplerList : u16 * AnimSamplerAssetID
dyn_array AnimCChannelList : u16 * ComponentAnimChannel
dyn_array AnimAChannelList : u16 * AssetAnimChannel

seq AnimationAsset
- samplers : AnimSamplerList
- component_channels : AnimCChannelList
- asset_channels     : AnimAChannelList
- duration_seconds   : f64 # total clip length; MUST be >= max sampler input time (or 0 for empty clips)
