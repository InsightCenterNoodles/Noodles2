; A 3D vector, with float precision
VEC3 = [ float, float, float ]

QUAT = [
	float,
	float,
	float,
	float
] ; xyz + w

ENTITY_ID = int

; Assign non-unique names to entities
NAME_COMPONENT = {
	0: text
}

; The position of this entity, in relation to it's parent, if one exists.
TRANSFORM_COMPONENT = { 
	; This can be specified in two ways,
	; Affine-wise, or Matrix-wise
	; It is an error to use both!
	; If neither, it is assumed to be default affine

	; Affine Wise ===================
	; Position. If missing, assume zero
	? 0: VEC3 
	; Rotation. If missing, assume the identity rotation
	? 1: QUAT 
	; Scale. If missing, assume one
	; A single float implies an isotropic scale
	? 2: VEC3 / float

	; Matrix Wise ===================
	; This must be exactly 16 floats for full transform matrix
	; Or a 3 row, 4 column matrix for a more compact matrix
	? 4: [16* float] / [12* float]
}

; This component is an ephemeral advisory component
; This means that the component is sent from client to server, with the
; server using it to consider updates to the system. The server does NOT send 
; this component back.
; In this case,
; The server is being informed that a client would like to move an entity.
; This is tied in with the interactivity components; clients should send this
; instead of an update to a transform component when human interaction is happening.
; an example is dragging a probe item.  In some cases, the server may
; want to do something on every proposed motion, but delay sending back a position
; update until it is really ready.
PROPOSED_TRANSFORM_COMPONENT = TRANSFORM_COMPONENT

INTERACTIVE_COMPONENT = { }

CAN_TRANSLATE_COMPONENT = {
	0: bool ; Axis lock
}

CAN_ROTATE_COMPONENT = {
	1: 0; Full rotation on all axis
       / 1 ; Rotation around UP only
}

CAN_SCALE_COMPONENT = {
	2: 0; Full scale on all axis
       / 1 ; Uniform scale only
}

ACTIVATE_COMPONENT = { 
; If 'activated' (clicked on desktop, tapped on mobile), 
; The first RPC_ENDPOINT_ID should be called with this entity as the
; first argument.
; Other IDs are provided to allow some platforms to be able to activate it in multiple ways
; (For example, right clicking on desktop). Not all platforms should be expected
; to provide access to these other activation options
	0: [ + RPC_ENDPOINT_ID ] 
}

; This needs smithing.
; The idea here is that some entities which represent something should
; have some configuration options
OPTIONS_COMPONENT = { text => any }

; If the entity is visible or not
VISIBLE_COMPONENT = { }

; The parent of this entity
CHILD_OF_COMPONENT = { 0: ENTITY_ID }

;; we can probably represent tables as an entity, and each row is an entity too?

; Probing
; The design here is to have a component that describes a probe
; The server sees this component being added, generates probe content
; and then removes the component?